# 1. 自定义事件对象
- 可以自定义新的事件类
    - 自定义的事件类<font color=red>必须继承自</font> `QEvent`
    - 自定义的事件类<font color=red>必须拥有全局唯一的 Type 值</font>
    - <font color=red>程序中必须提供处理自定义事件对象的方法</font>

- 自定义事件类
    1. 将`QEvent`作为父类继承
    2. 指定全局唯一的 `Type` 值
    ```cpp
    class StringEvent:public QEvent
    {
    public:
        static const Type TYPE = static_cast<Type>(QEvent::User + OxFF);
        //...
    };
    ```

- Qt中事件的 `Type` 值
    - 每个事件类都拥有<font color=red>全局唯一</font>的 Type 值
    - 自定义事件类的 Type 值也需要自定义
    - 自定义事件类使用 `QEvent::User` 之后的值作为 Type 值
    - 程序中保证 `QEvent::User + VALUE` 全局唯一即可

- 处理自定义事件对象的方法
    1. 将<font color=red>事件过滤器</font>安装到目标对象
        - 在 `eventfilter()` 函数中编写自定义事件的处理逻辑
    2. 在目标对象的类中<font color=red>重写事件处理函数</font>
        - 在 `event()` 函数中编写自定义事件的处理逻辑

# 2. 编程实验 发送和处理自定义事件
实验目录：[44-1](vx_attachments\044_Sending_custom_events_2\44-1)

- <font color=red>为什么</font>要自定义事件类？
	- 需要<font color=red>扩展</font>一个已有组件类的功能
	- 需要开发一个<font color=red>全新功能</font>的组件类
	- 需要向一个<font color=red>第三方的组件类</font>发送消息
	- 。。。

# 3. 小结
- 自定义事件类<font color=red>必须继承自</font> `QEvent`
- 自定义事件类使用 `QEvent::User` 之后的值作为 Type 值
- 自定义事件类的 `Type` 值必须全局唯一
- <font color=red>程序中需要提供自定义事件类的处理方法</font>
