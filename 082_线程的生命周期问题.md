# 线程的生命期问题
- 一个工程中的实际冋题
    C++对象有生命周期；
    线程也有生命周期；
    QThread 对象的生命周期与对应的线程生命周期是否一致 ？

- 工程实践中的经验准则
    ![](_v_images_/.png)

- 下面的代码有问题吗？
    ![](_v_images_/.png)

# 编程实验 线程生命期冋题


- 同步型线程设计
    - 概念
        - 线程对象主动等待线程生命期结束后才销毀
    - 特点
        - 同时支持在栈和堆中创建线程对象
        - 对象销毀时确保线程生命期结束
    - 要点
        - 在析构函数中先调用wait()函数，强制等到线程运行结束
    - 使用场合
        - 线程生命期相对较短的情形

        ```c
        SyncThread::~SyncThnead()
        {
            wait();

            // do something to release resource
        }
        ```

# 编程实验 同步型线程设计

- 异步型线程设计
    - 概念
        - 线程生命期结束时通知销毀线程对象
    - 特点
        - 只能在堆中创建线程对象
        - 线程对象不能被外界主动销毀
    - 要点
        - 在 run() 中最后调用 deleteLater() 函数
        - 线程体函数主动申请销毀线程对象
    - 使用场合
        - 线程生命期不可控，需要长时间运行于后台的情形

        ```c
        void AsyncThread::run()
        {
            for(int i = 0; i < 5; i++)
            {
                // do something complicated
            }

            // apply to destory thread object

            deleteLater();
        }
        ```

# 编程实验 异步型线程设计

# 小结
- 线程对象生命期必须大于对应线程生命期
- 同步型线程设计 - 线程生命期较短
- 异步型线程设计 - 线程生命期不可控
- 线程类的设计必须适应具体的场合
- 没有万能的设计，只有合适的设计
