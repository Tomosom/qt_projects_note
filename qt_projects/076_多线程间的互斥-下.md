多线程间的互斥

■问题
程序有多少临界资源？需要多少线程锁？ 

■—般觀则
每一^临界资源都需要一^线程锁进行保护!

■有趣的示例
![](_v_images_/.png)

编程实验 有趣的示例

■线程的死锁概念
-线程间相互等待临界资源而造成彼此无法繼卖执行

■发生死锁的条件
-系统中存在多个临界资源且临界资源不可抢占
一线程需要多个临界资源才自阅齡卖执行
![](_v_images_/.png)

■死锁的避免
-对所有的临界资源都分配一个唯一的序号（「1, r2
,…，rn
)
-对应的线程锁也分配同样的序号（nr^, m2/…，mn
)
-系统中的每个线程按照严搭递增的次序请求资源
![](_v_images_/.png)

■信号量的概念
-信号量是街朱的线程锁
-信号量允许N个线程同时访问临界资源
—Qt中;ffi妾支持信号量（QSemaphore )

■ QSemaphore使用示例
![](_v_images_/.png)
• QSemaphore对象中進护了一个整型值
• acquire()使得该值减1, release()使得该值加1
当该值为0时，acquire()函数将阻塞当前线程

编程实验 再论生产消费者问题

小结
■多线程间相互等待临界资源彳等导致死锁
■可以对临界资源进行编号的方法避免死锁
■所有线程必须按照严格递增的次序请求资源
■ Qt中直接支持信号量（QSemaphore)
■信号量允许N个线程同时访问临界资源
