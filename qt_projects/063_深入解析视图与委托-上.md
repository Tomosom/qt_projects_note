深入解析视图与委托
- 深度的思考
委托是视图的构成部分，那么委托是否帮
助视图显示具体数据呢？

- 分析
Qt中的委托作为视图的内部组件而存在，因
此，委托是视图的一g|5分；必然，委托需要承
担数据显示的部分工作。

编程实验 委托与视图 

- 实验结论
-视图负责确定数据项的组织显示方式（列表，树形，表格）
一委托负责具体数据项的显示和编辑（数据值，编辑器）
-视图和委托共同完成数据显示功能和数据编辑功能


- 拓展的思考
如何改变视图默认的数据显示方式？
![](_v_images_/.png)

- 自定义委托的默认数据显示方式
1•重写paint成员函数
2•在paint中自定义数据显示方式
3. 重写editorEvent成员函数
4. 在editorEvent中处理交互事件

- 在paint中自定义数据显示方式
if (index.data().type() == QVariant::Bool)
{
bool data = index.model()->data(index, Qt::DisplayRole).toBool();
QStyleOptionButton checkBoxStyle; // 组供会制参数
/*设置具体的绘制参数V
checkBoxStyle.state = data ? QStyle::State一On : QStyle::State_Off;
checkBoxStyle.state |= QStyle::State一Enabled;
checkBoxStyle.rect = option.rect;
checkBoxStyle.rect.setx(option.rect.x() + option.rect.width() / 2 - 6
/大樹匡参截绘制组件（数据顶自定义Sz予方式）"
QApplication:: style ()->drawControl (QStyle : :CE_CheckBox,
&checkBoxStyle,
painter);
}

- 在editorEvent中处理交互事件
if( index.data().type() == QVariant::Bool)
{
QMouseEvent* mouseEvent = dynamic_cast<QMouseEvent*> (event);
if (event->type() == QEvent::MouseButtonPress &&
option.rect.contains(mouseEvent->pos()))
{
bool data = model->data(index, Qt::DisplayRole).toBool();
mode1setData(index, I data, Qt::DisplayRole);
}
}

编程实验 自定义数据项显示

小结
- 委托是视图的重要构造部分
- 视图负责数据项的组织显示方式
- 委托负责具体数?居项中数值的显示方式
- 重写委托的paint函数自定义数据项显示方式
- 重写委托的editorEvent函数处理交互事件

