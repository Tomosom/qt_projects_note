模型视图中的委托

■委托的本质
-为视图提供数据编辑的上下文环境
-产生界面元素的工厂类
-能够使用和设置模型中的数据

■问题
如何自定一个委托类？

■自定义委托时需要重写的函数
1. createEditor
2. updateEditorGeometry
3. setEditorData
4. setModelData
5_ paint (可选）

重写creatorEditor成员函数
-根据索引中值的类型创建编辑器组件
QWidget* createEditor( /* parameter */ ) const
{
QWidget* ret = NULL;
if( index * data()* type() == QVariant::Bool ) {
/* create check box ★/
} else if( index*data〇 *type〇 == QVariant::Char
/* create combo box ★/
} else {
/* default */
}
return ret;
}

2•重写 updateEditorGeometry 成员函数
-根据参数中数?居项的信息设置编辑器的位置和大小
void updateEditorGeometry (
QWidget *editor,
const QStyleOptionViewItem &option,
const QModelIndex &index) const
{
editor->setGeometry(option*rect);
}

3.重写setEditorData成员函数
-根据参数中的数据索引设置编辑器中的初始数据
void setEditorData(QWidget ^editor,
const QModellndex &index ) const
{
if( index * data()* type() == QVariant::Bool ) {
QCheckBox* cb = dynamic_cast<QCheckBox*>(editor);
/* set data to editor */
} else if( index*data〇 *type〇 == QVariant::Char ) {
QComboBox* cb = dynamic_cast<QComboBox*>(editor);
/* set data to editor */
} else {
QItemDelegate::setEditorData(editor, index);
}
}

4.重写setModelData成员函数
-根据参数中的数据索引更改模型中的数据
void setModelData(QWidget *editor,
QAbstractltemModel *model,
const QModellndex &index) const
{
if( index * data()* type() == QVariant::Bool ) {
QCheckBox* cb = dynamic_cast<QCheckBox*>(editor);
/* set data to model from editor */
} else if( index*data〇 *type〇 == QVariant::Char ) {
QComboBox* cb = dynamic_cast<QComboBox*>(editor);
/* set data to model from editor */
} else {
/* default action from parent class */
}
}

5•重写paint成员函数（可选）
-根据参数中的信息绘制编辑器
void paint(QPainter ^painter,
const QStyleOptionViewItem &option,
const QModellndex &index) const
{
if ( /* condition */ ) {
/* customized paint action */
} else {
QItemDelegate::paint(painter, option, index);
}
}

编程实验 自定义委托

■问题
自定义委托时重写的函数由谁调用？

小结
■自定委托类时需要重写相应的成员函数
■根据需要创建编辑组件并设置组件中的数据
■编辑结束后将数据返回模型
■成员函数的参数携带了数据存取时需要的信息

