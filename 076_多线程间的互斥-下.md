# 多线程间的互斥
- 问题
    程序有多少临界资源？需要多少线程锁？ 

- —般觀则
    每一个临界资源都需要一个线程锁进行保护!

- 有趣的示例
    ![](_v_images_/.png)

# 编程实验 有趣的示例

- 死锁
    - 线程的死锁概念
        - 线程间相互等待临界资源而造成彼此无法繼卖执行
    - 发生死锁的条件
        - 系统中存在多个临界资源且临界资源不可抢占
        - 线程需要多个临界资源才自阅齡卖执行

    ![](_v_images_/.png)

- 死锁的避免
    - 对所有的临界资源都分配一个唯一的序号（r~1~, r~2~, …, r~n~)
    - 对应的线程锁也分配同样的序号（m~1~, m~2~, …, m~n~)
    - 系统中的每个线程按照严搭递增的次序请求资源

    ![](_v_images_/.png)

- 信号量的概念
    - 信号量是特殊的线程锁
    - 信号量允许N个线程同时访问临界资源
    - Qt中直接支持信号量（QSemaphore )

- QSemaphore使用示例
    ![](_v_images_/.png)
    - QSemaphore对象中维护了一个整型值
    - acquire()使得该值减1, release()使得该值加1
    - 当该值为0时，acquire()函数将阻塞当前线程

# 编程实验 再论生产消费者问题

# 小结
- 多线程间相互等待临界资源将导致死锁
- 可以对临界资源进行编号的方法避免死锁
- 所有线程必须按照严格递增的次序请求资源
- Qt中直接支持信号量（QSemaphore)
- 信号量允许N个线程同时访问临界资源
