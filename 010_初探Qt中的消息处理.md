# 1. Qt消息模型
- Qt封装了具体操作系统的消息机制
- Qt遵循经典的GUI消息驱动事件模型
![](vx_images/.png)

# 2. 思考
- Qt中如何表示用户消息？
- Qt中如何映射用户消息到消息处理函数？
- Qt中消息映射需要遵循什么规则？

# 3. 信号与槽
- Qt中定义了与系统消息相关的概念
    - 信号(Signal)
        - 由操作系统产生的消息
    - 槽(Slot)
        - 程序中的消息处理函数
    - 连接(Connect)
        - 将系统消息绑定到消息处理函数

- Qt中的消息处理机制
![](vx_images/.png)
信号到槽的连接必须发生在两个Qt类对象之间！

- Qt 的核心 - QObject::connect 函数

```c
bool connect(const QObject *sender,   //发送对象
             const char *signal,      //消息名
             const QObject *receiver, //接收对象
             const char *method,      //接受对象的成员函数
             Qt::ConnectionType type = Qt::Autoconnection);
```
> Note :
> 在Qt中，消息用字符串进行描述
> connect函数在消息名和处理函数之间建立映射

- Qt中的“新”关键字
    - SIGNAL
        - 用于指定消息名
    - SLOT
        - 用于指定消息处理函数名
    - Q_OBJECT
        - 所有自定义槽的类必须叫声明的开始处加上Q_OBJECT
    - slots
        - 用于在类中声明消息处理函数

# 4. 编程实验 初探信号与槽 `10-1.pro`

# 5. 自定义槽
- 只有QObject的子类才能自定义槽
- 定义槽的类必须在声明的最开始处使用Q_OBJECT
­- 类中声明槽时需要使用slots关键字
- 槽与所处理的信号在函数签名上必须一致
- SIGNAL和SLOT所指定的名称中：
    - 可以包含参数类型
    - 不能包含具体的参数名

# 6. 编程实验 为计算器实例添加消息处理函数

# 7. 小贴士
- 解决经典问题：Object::connect: No such slot...
    1. 检查类是否继承于QObject
    2. 检查类声明的开始处是否添加Q_OBJECT
    3. 检查是否使用slots关键字进行槽声明
    4. 检查槽的名称是否拼写错误
    5. 重新执行qmake

# 8. 小结
- 信号与槽是Qt中的核心机制
- 不同的Qt对象可以通过信号和槽进行通信
- 只有QObject的子类才能自定义信号和槽
- 使用信号和槽的类必须在声明的最开始处使用QOBJECT
- 信号与处理函数在函数签名上必须一致
