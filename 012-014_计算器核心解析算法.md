# 1. 数字和运算符的分离
## 1.1. 问题
计算机如何读懂四则运算表达式？
`"9.3 + (3 - -0.11) * 5"`

## 1.2. 中缀表达式与后缀表达式
- 人类习惯的数学表达式叫做<font color=red>中缀表达式</font>
- 另外，还有一种将<font color=red>运算符放在数字后面</font>的<font color=red>后缀表达式</font>
- 实例：

```
          5 + 3  ->  5 3 +
      1 + 2 * 3  ->  1 2 3 * +
9 + (3 - 1) * 5  ->  9 3 1 - 5 * +
```

- <font color=red>中缀表达式</font>符合人类的<font color=red>阅读</font>和<font color=red>思维</font>习惯
- <font color=red>后缀表达式</font>符合计算机的<font color=red>运算</font>方式
    - 消除了中缀表达式中的括号
    - 同时保留中缀表达式中的运算优先级

## 1.3. 计算器核心算法
- 解决方案
    1. 将中缀表达式进行<font color=red>数字</font>和<font color=red>运算符</font>的<font color=red>分离</font> (第一节内容)
    2. 将中缀表达式<font color=red>转换</font>为后缀表达式
    3. 通过后缀表达式<font color=red>计算最终结果</font>

## 1.4. 分离算法分析
- 所要计算的中缀表达式中包含：
    - 数字和小数点【<font color=red>0 - 9 或 .</font>】
    - 符号位【<font color=red>+ 或 -</font>】
    - 运算符【<font color=red>+, -, *, /</font>】
    - 括号【<font color=red>( 或 )</font>】

- 思想：<font color=red>以符号作为标志</font>对表达式中的字符逐个访问
    - 定义累计变量 `num` (字符串变量)
    - 当前字符 `exp[i]` 为<font color=red>数字</font>或<font color=red>小数点</font>时
        - 累计：`num += exp[i]`
        > `exp` 为中缀表达式字符串
    - 当前字符 `exp[i]` 为<font color=red>符号</font>时
        - `num` 为运算数，分离并保存
        - 若 `exp[i]` 为<font color=red>正负号</font>：
            - 累计符号位 + 和 - ：`num += exp[i]`
        - 若 `exp[i]` 为<font color=red>运算符</font>：
            - 分离并保存

    ```c
    for (int i = 0; i < exp_length(); i++) {
        if (exp[i] 为数字或小数点)
            累计: num += exp[i];
        else if (exp[i] 为符号) {
            if (num != "") {
                分离并保存运算数: num;
            }

            if (exp[i] 为正号或负号) {
                符号位累计: num += exp[i];
            } else { // 运算符
                分离并保存运算符: exp[i];
            }
        }
    }
    ```

- 难点：
    - 如何区分<font color=red>正负号</font>与<font color=red>加减号</font>?
        - 是正负号的情况：
            - `+` 和 `-` 在表达式的第一个位置
            - 括号后的 `+` 和 `-`
            - 运算符后的 `+` 和 `-`
            > 例：`+9 + (-3 - -1) * -5`

## 1.5. 编程实验 表达式分离算法
工程目录：[Calculator](vx_attachments\012~014_calculator_add_algorithm\Calculator)
函数实现：
    分离算法：`QQueue<QString> QCalculatorDec::split(const QString& exp)`

## 1.6. 小结
- <font color=red>QString</font>中的每个字符为<font color=red>QChar</font>
- Qt中<font color=red>提供了</font>开发中<font color=red>不可或缺的数据结构类</font>
- 四则运算表达式的计算分三个步骤
    1. <font color=red>数字和符号分离</font>
    2. 中缀表达式转后缀表达式
    3. 根据后缀表达式计算结果

# 2. 中缀表达式转后缀表达式
## 2.1. 中缀转后缀
- <font color=red>中缀表达式</font>转<font color=red>后缀表达式</font>的过程类似<font color=red>编译过程</font>（输入的表达式有问题需提示错误）
    - 四则运算表达式中的<font color=red>括号必须匹配</font>
    - <font color=red>根据运算符优先级进行转换</font>
    - <font color=red>转换后的表达式中没有括号</font>
    - <font color=red>转换后可以顺序的计算出最终结果</font>

- 转换过程：
    - 当前元素e为<font color=red>数字</font>：输出
    - 当前元素e为<font color=red>运算符</font>：
        1. 与<font color=red>栈</font>顶运算符进行优先级比较
        2. 小于等于：将栈顶元素输出，转1
        3. 大于：将当前元素e入栈
    - 当前元素e为<font color=red>左括号</font>：
        1. 入栈
    - 当前元素e为<font color=red>右括号</font>：
        1. 弹出栈顶元素并输出，直至栈顶元素为左括号
        2. 将栈顶的左括号从栈中弹出

```c
while (!exp.isEmpty()) {
    QString e = exp.dequeue();

    if (isNumber(e)) {
        输出 : e;
    } else if (isOperator(e)) {
        while (priority(e) <= priority(stack.top()))
            输出栈顶元素, stack.pop();
        stack.push(e);
    } else if (isLeft(e)) {
        stack.push(e);
    } else if (isRight(e)) {
        while (!isLeft(stack.top())) {
            输出栈顶元素, stack.pop();
        }
        从栈中弹出左后号 : stack.pop();
    }
}
```

- 关键点：转换过程中左右括号是重要标志
    - 如何确保中缀表达式中的括号能够左右匹配？

## 2.2. 括号匹配算法
- 合法的<font color=red>四则运算表达式</font>中
    - 括号<font color=red>匹配成对</font>出现
    - <font color=red>左括号必然先于右括号出现</font>

```c
for (int i = 0; i < len; i++) {
    if (exp[i]为左括号) {
        exp[i]入栈;
    } else if (exp[i]为右括号) {
        if (栈顶元素为左括号) {
            将栈顶元素弹出;
        } else {
            匹配错误;
        }
    }
}
```

## 2.3. 编程实验 中缀表达式转后缀表达式
工程目录：[Calculator](vx_attachments\012~014_calculator_add_algorithm\Calculator)
函数实现：
    括号匹配算法：`bool match(QQueue<QString> &exp);`
    转换算法：`bool transform(QQueue<QString> &exp, QQueue<QString> &output);`

## 2.4. 小结
- 后缀表达式是程序<font color=red>计算复杂表达式的基础</font>
- 中缀到后缀的转换是<font color=red>基于栈数据结构</font>的
- 转换过程能够<font color=red>发现</font>表达式中的<font color=red>语法错误</font>

# 3. 根据后缀表达式计算结果
## 3.1. 计算思路
- <font color=red>遍历</font>后缀表达式中的<font color=red>数字</font>和<font color=red>运算符</font>
    - 当前元素为<font color=red>数字</font>：<font color=red>进栈</font>
    - 当前元素为<font color=red>运算符</font>：
    1. 从栈中弹出右操作数
    2. 从栈中弹出左操作数
    3. 根据符号进行运算
    4. 将运算结果压入栈中
- 遍历结束
    - 栈中的唯一数字为运算结果

```c
while (!exp.isEmpty()) {
    if (当前元素为数字) {
        入栈;
    } else if (当前元素为运算符) {
        1. 从栈中弹出右操作数;
        2. 从栈中弹出旬累作数;
        3. 根据符号进行运算;
        4. 将运卓吉果压入栈中;
    }
    else
        表达式错误;
}
```

- 注意
    - 与数学计算相关的算法都需要考虑除0的情况
    - 若是浮点运算，避免代码中直接与0做相等比较

    ```c
    const double P = 0.000000000000001;

    if ((-P < r) && (r < P)) {
        ret = "Error";
    } else {
        ret.sprintf("%f", l / r);
    }
    ```
    > 不能和0直接做相等比较，因为浮点数在内存里的表示是不精确的
    > 不能保证所有的编译器都能做到直接和0比较

## 3.2. 编程实验 计算后缀表达式
工程目录：[Calculator](vx_attachments\012~014_calculator_add_algorithm\Calculator)
函数实现：
    最终结果计算函数：`QString calculate(QQueue<QString> &exp);`
    算法类的对外接口：`bool expression(const QString& exp);`

## 3.3. 小结
- 计算方法由<font color=red>3</font>个不同的子算法构成
- Qt项目在整体上采用<font color=red>面向对象分析与设计</font>
- 局部的算法设计依旧采用<font color=red>面向过程</font>的方法完成
- Qt开发是<font color=red>各种开发技术的综合运用</font>(数据库，数据结构，各个领域等)
