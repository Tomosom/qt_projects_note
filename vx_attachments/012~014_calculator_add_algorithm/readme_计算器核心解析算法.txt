Calculator工程:添加算法

1. 后缀表达式
    - 人类习惯的数学表达式叫做中缀表达式(运算符放中间)
    - 另外,还有一种将运算符放在数字后面的 后缀表达式
    - 实例:
        5 + 3 → 5 3 +
        1 + 2 * 3 → 1 2 3 * +
        9 + (3 - 1) * 5 → 9 3 1 - 5 * +
    - 后缀表达式符合计算机的运算方式
        消除了中缀表达式中的括号
        同时保留中缀表达式中的运算优先级
        
2. 计算器的核心算法
    - 将中缀表达式进行数字和运算符的分离
    - 将中缀表达式转化为后缀表达式
    - 通过后缀表达式计算最终结果
    
3. 数字和运算符分离
    所要计算的中缀表达式中包含
    - 数字和小数点 [ 0-9 或 . ]
    - 符号位 [ + 或 - ]
    - 运算符 [ +, -, *, / ]
    - 括号 [ ( 或 ) ]
    
        9.3 + ( 3 - -0.11 ) * 5
     
    思想:以符号作为标志对表达式中的字符逐个访问
    - 定义累计变量 num
    - 当前字符 exp[i] 为数字或小数点时:
        累计: num += exp[i]
    - 当前字符 exp[i] 为符号时:
        num为运算数, 分离并保存
        若 exp[i] 为正负号:
            累计符号位 + 和 - : num += exp[i]
        若 exp[i] 为运算符:
            分离并保存
            
    伪代码:
    for (int i = 0l i < exp.length(); i++) {
        if (exp[i]为数字或小数点) {
            累计:num += exp[i];
        } else if (exp[i]为符号) {
            if (num != "") {
                分离并保存运算数:num;
            }
            
            if (exp[i]为正号或负号) { // ?
                符号位累计:num += exp[i];
            } else {
                分离并保存运算符:exp[i];
            }
        }
    }
    
    难点: 如何区分正负号与加号和减号?
    肉眼观察:
    - + 和 - 在表达式的第一个位置 (前一个字符为空)
    - 左括号后的 + 和 -           (前一个字符为左括号)
    - 运算符后的 + 和 -           (前一个字符为运算符)
    
        +9 + ( -3 - -1 ) * -5

4. 中缀转后缀
    中缀表达式转后缀表达式的过程类似编译过程
    - 四则运算表达式中的括号必须匹配
    - 根据运算符优先级进行转换
    - 转换后的表达式中没有括号
    - 转换后可以顺序地计算出最终结果
    
    转换过程:(栈 用来保存中缀表达式中的运算符)
    - 当前元素 e 为数字: 输出
    - 当前元素 e 为运算符:
        与栈顶运算符进行优先级比较
        小于等于: 将栈顶元素输出, 转1
        大于: 将当前元素 e 入栈
    - 当前元素 e 为左括号: 入栈
    - 当前元素 e 为右括号: 
        弹出栈顶元素并输出,直到栈顶元素为左括号
        将栈顶的左括号从栈中弹出
        
    伪代码:(exp 为 通过分离算法得到的队列)
    while (!exp.isEmpty()) {
        QString e = exp.dequeue();
        
        if (idNumber(e)) {
            输出: e;
        } else if (isOperator(e)) (
            while ( priority(e) <= priority(stack.top()) ) {
                输出栈顶元素, stack.pop();
            }
            stack.push(e);
        ) else if (isLeft(e)) {
            stack.push(e);
        } else if (isRight(e)) {
            while( !isLeft(stack.top()) ) {
                输出栈顶元素, stack.pop();
            }
            从栈中弹出左括号: stack.pop();
        }
    }
    
    关键点:转换过程中左右括号是重要标识,如何确保表达式中的括号能够左右匹配?
    合法的四则运算表达式中
    - 括号匹配成对出现
    - 左括号必然先于右括号出现
        伪代码:
        for (int i = 0; i < len; i++) {
            if (exp[i] 为左括号) {
                exp[i] 入栈;
            } else if (exp[i] 为右括号) {
                if (栈顶元素为左括号) {
                    将栈顶元素弹出;
                } else {
                    匹配错误;
                }
            } 
        }
        
5. 后缀表达式计算
    遍历后缀表达式中的数字和运算符
    - 当前元素为数字: 进栈
    - 当前元素为运算符:
        从栈中弹出右操作数 (弹出的第一个值)
        从栈中弹出左操作数 (弹出的第二个值)
        根据符号进行运算
        将运算结果压入栈中
    遍历结束
    - 占中的唯一数字为运算结果
        
    伪代码:
    while (!exp.isEmpty()) {
        if (当前元素为数字) {
            入栈;
        } else if (当前元素为运算符) {
            1. 从栈中弹出右操作数;
            2. 从栈中弹出左操作数;
            3. 根据符号进行运算;
            4. 将运算结果压入栈中;
        } else {
            表达式错误;
        }
    }
    
    注意
    - 与数学计算相关的算法都需要考虑除0的情况(因为浮点数在内存中的表示是不精确的)
    - 若是浮点运算,避免代码中直接与0做相等比较(为了兼容比较老的编译器)
        const double P = 0.0000000000000001;    // 定义一个比较小的数
        if ( (-P < r) && (r < P) ) {
            ret = "Error";
        } else {
            ret.sprintf("%f", 1 / r);
        }